---
title: 关于stc单片机远程升级的相关验证
date: 2023-01-17 11:16:31
tags: stc
categories: 单片机
---

### 关于stc单片机远程升级的相关验证：

##### 猜想：

1.去掉A51中的AT指向地址，只在target定义首地址，看编译后的m51文件里code地址是否发生变化。（猜想：应该不变）。

2.验证猜想：目前的bootloader因为中断偏移量是0，程序上电后，从flash的起始地址的复位中断向量入口指向bootloader的复位中断程序地址，执行复位中断程序，执行完复位中断程序后，自动跳转到main主程序。实则此时的单片机是把bootloader当成了用户AP程序（从ap程序里满足条件，则IAP_CONTR = 0×20（而不是0×60)复位至用户程序区也可以看出）。
Tips：之所以不用在ap里写明函数指针跳转地址，而是直接用IAP_CONTR表示跳转，也是因为stc单片机自动把IAP_CONTR的结果对应处理到了跳转程序的启动地址。

3.验证猜想：m51文件里的code地址，前面地址是不是都对应着中断向量地址，而main地址在中断向量地址表示完的后面。可以查看对比ap和bootloader的m51文件。

4.根据网上的方法，将bootloader放在首地址，ap放在规划地址上，更改中断偏移量，看方案是否可行。

##### 回答：

1.AT只改变复位中断向量入口地址，不改变code的地址分配。所以不变。

2.中断偏移量只更改中断向量表的地址。单片机上电后，程序先找到AT中指向的复位中断向量入口地址，然后跳转到该地址执行复位中断程序。复位中断程序执行完后，跳转到main函数执行主程序。此处BootLoader没改AT，没改中断偏移量，只改了code地址分配，所以复位中断向量入口地址指向的是BootLoader的复位中断程序startup。所以此时实际上BootLoader被单片机当成了用户AP程序，通过IAP_CONTR = 0×20（而不是0×60)即可复位到该BootLoader程序。

3.从hex文件查看可知，一般main函数执行，都是先初始化前面其他函数配置，包括中断向量的初始化。最后再跳转至main函数执行。

4.不可行。

