<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>蜃楼的个人博客</title>
  
  <subtitle>学习笔记</subtitle>
  <link href="https://shenlou99.github.io/atom.xml" rel="self"/>
  
  <link href="https://shenlou99.github.io/"/>
  <updated>2023-03-11T09:05:12.386Z</updated>
  <id>https://shenlou99.github.io/</id>
  
  <author>
    <name>蜃楼</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C语言标准库——vsprintf</title>
    <link href="https://shenlou99.github.io/2023/03/11/C%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86%E5%BA%93%E2%80%94%E2%80%94vsprintf/"/>
    <id>https://shenlou99.github.io/2023/03/11/C%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86%E5%BA%93%E2%80%94%E2%80%94vsprintf/</id>
    <published>2023-03-11T08:46:16.000Z</published>
    <updated>2023-03-11T09:05:12.386Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><p>vsprintf是C语言库函数之一，属于可变参数。用于向字符串中打印数据、数据格式用户自定义。</p><p>头文件是：**#include “stdarg.h”**</p><p><strong>函数声明：</strong></p><p>int vsnprintf(char* str,size_t size,const char* format,va_list ap);</p><p><strong>参数说明：</strong></p><p>char* str[out]：把生成的格式化的字符串存放在这里。</p><p>size_t size：str可接受的最大字符数（<strong>非字节数</strong>）。注意防止数组越界！</p><p>const char* format：指定输出格式的字符串。</p><p>va_list ap：va_list变量。</p><p><strong>函数功能：</strong></p><p>将可变参数格式化输出到一个字符数组。</p><p><strong>返回值：</strong></p><p>执行成功，返回最终生成字符串的长度，若生成字符串的长度大于size，则将字符串的前size个字符复制到str，同时将原串的长度返回（不包含终止符）；</p><p>执行失败，则返回负值，并置errno。</p><h2 id="二、示例"><a href="#二、示例" class="headerlink" title="二、示例"></a>二、示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdarg.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintFError</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format,...)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> buffer[<span class="number">256</span>];</span><br><span class="line">va_list args;</span><br><span class="line">va_start(args,format);</span><br><span class="line">vsnprintf(buffer,<span class="number">256</span>,format,args);</span><br><span class="line">perror(buffer);</span><br><span class="line">va_end(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">FILE* pFile;</span><br><span class="line"><span class="type">char</span> szFileName[] = <span class="string">&quot;myfile.txt&quot;</span>;</span><br><span class="line">pFile = fopen(szFileName,<span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(pFile == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">PrintFError(<span class="string">&quot;Error opening &#x27;%s&#x27;&quot;</span>,szFileName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">fclose(pFile);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、定义&quot;&gt;&lt;a href=&quot;#一、定义&quot; class=&quot;headerlink&quot; title=&quot;一、定义&quot;&gt;&lt;/a&gt;一、定义&lt;/h2&gt;&lt;p&gt;vsprintf是C语言库函数之一，属于可变参数。用于向字符串中打印数据、数据格式用户自定义。&lt;/p&gt;
&lt;p&gt;头文件是：**</summary>
      
    
    
    
    <category term="C语言标准库" scheme="https://shenlou99.github.io/categories/C%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86%E5%BA%93/"/>
    
    
    <category term="vsprintf" scheme="https://shenlou99.github.io/tags/vsprintf/"/>
    
  </entry>
  
  <entry>
    <title>C语言标准库——va_list</title>
    <link href="https://shenlou99.github.io/2023/03/11/C%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86%E5%BA%93%E2%80%94%E2%80%94va-list/"/>
    <id>https://shenlou99.github.io/2023/03/11/C%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86%E5%BA%93%E2%80%94%E2%80%94va-list/</id>
    <published>2023-03-11T07:41:21.000Z</published>
    <updated>2023-03-11T08:38:23.375Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><p>va_list是在C语言中解决变参问题的一组宏，所在头文件：**#include&lt;stdarg.h&gt;**，用于获取不确定个数的参数。</p><h2 id="二、意义"><a href="#二、意义" class="headerlink" title="二、意义"></a>二、意义</h2><p>当你的函数的参数个数不确定时，就可以使用上述宏进行动态处理。</p><h2 id="三、使用方法"><a href="#三、使用方法" class="headerlink" title="三、使用方法"></a>三、使用方法</h2><ul><li>首先在函数中定义一个具有va_list型的变量，这个变量是指向参数的指针。</li><li>然后用va_start() 宏初始化变量刚定义的va_list变量，使其指向第一个可变参数的地址。</li><li>然后va_arg返回可变参数，va_arg的第二个参数是你要返回的参数的类型（如果多个可变参数，依次调用va_arg获取各个参数）。</li><li>最后使用va_end宏结束可变参数的获取。</li></ul><h2 id="四、注意点"><a href="#四、注意点" class="headerlink" title="四、注意点"></a>四、注意点</h2><p>在使用va_list时应该注意以下问题：</p><ul><li>可变参数的类型和个数完全由代码控制，它并不能智能地识别不同参数的个数和类型。</li><li>如果我们不需要一一详解每个参数，只需要将可变列表拷贝到某个缓冲区，可以用vsprintf函数。</li><li>因为编译器对可变参数的函数原型检查不够严格，对编程查错不利，不利于我们写出高质量的代码。</li></ul><h2 id="五、示例"><a href="#五、示例" class="headerlink" title="五、示例"></a>五、示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdarg.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">char</span>* msg,...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">total = <span class="built_in">sum</span>(<span class="string">&quot;hello world&quot;</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;total = &quot;</span> &lt;&lt; total &lt;&lt;std::endl;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">char</span>* msg,...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">va_list vaList;<span class="comment">//定义一个具有va_list型的变量，这个变量是指向参数的指针。</span></span><br><span class="line"><span class="built_in">va_start</span>(vaList,msg);<span class="comment">//第一个参数指向可变列表的地址，地址自动增加，第二个参数为固定值</span></span><br><span class="line">std::cout &lt;&lt; msg &lt;&lt; std::endl;</span><br><span class="line"><span class="type">int</span> sumNum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> step;</span><br><span class="line"><span class="keyword">while</span>((step = <span class="built_in">va_arg</span>(vaList,<span class="type">int</span>)) &lt; <span class="number">4</span>)<span class="comment">//va_arg第一个参数是可变参数的地址，第二个参数是传入参数的类型，返回值就是va_list中接着的地址值，类型和va_arg的第二个参数一样。</span></span><br><span class="line">        <span class="comment">//不等于0表示，va_list中还有参数可取</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//va_arg取得下一个指针</span></span><br><span class="line">sumNum += step;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">va_end</span>(vaList);<span class="comment">//结束可变参数列表</span></span><br><span class="line"><span class="keyword">return</span> sumNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p>hello world</p><p>total&#x3D;6</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、定义&quot;&gt;&lt;a href=&quot;#一、定义&quot; class=&quot;headerlink&quot; title=&quot;一、定义&quot;&gt;&lt;/a&gt;一、定义&lt;/h2&gt;&lt;p&gt;va_list是在C语言中解决变参问题的一组宏，所在头文件：**#include&amp;lt;stdarg.h&amp;gt;**，用于获</summary>
      
    
    
    
    <category term="C语言标准库" scheme="https://shenlou99.github.io/categories/C%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86%E5%BA%93/"/>
    
    
    <category term="va_list" scheme="https://shenlou99.github.io/tags/va-list/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://shenlou99.github.io/2023/03/11/hello-world/"/>
    <id>https://shenlou99.github.io/2023/03/11/hello-world/</id>
    <published>2023-03-11T07:36:34.465Z</published>
    <updated>2023-03-11T07:36:34.465Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ESP8266通信——AP模式（电脑作为客户端，8266作为服务器，无需路由器）</title>
    <link href="https://shenlou99.github.io/2023/03/09/ESP8266%E9%80%9A%E4%BF%A1%E2%80%94%E2%80%94AP%E6%A8%A1%E5%BC%8F/"/>
    <id>https://shenlou99.github.io/2023/03/09/ESP8266%E9%80%9A%E4%BF%A1%E2%80%94%E2%80%94AP%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-03-09T08:32:41.000Z</published>
    <updated>2023-03-11T07:36:34.461Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、ESP8266配置"><a href="#一、ESP8266配置" class="headerlink" title="一、ESP8266配置"></a>一、ESP8266配置</h2><p>在串口助手中，通过AT指令配置ESP8266的AP模式。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.AT测试AT是否OK</span><br><span class="line">2.AT+RST软重启模组</span><br><span class="line">3.AT+<span class="attribute">CWMODE</span>=2配置AP模式</span><br><span class="line">4.AT+<span class="attribute">CWSAP_DEF</span>=<span class="string">&quot;SSID&quot;</span>,&quot;password&quot;,5,4   设置ESP8266的AP信息</span><br><span class="line">AT+<span class="attribute">CWSAP_DEF</span>=&lt;ssid&gt;,&lt;pwd&gt;,&lt;chl&gt;,&lt;ecn&gt;[,&lt;max conn&gt;][,&lt;ssid hidden&gt;]</span><br><span class="line">5.AT+CIFSR查询本机IP</span><br><span class="line">6.AT+<span class="attribute">CIPMUX</span>=1开启多连接</span><br><span class="line">7.AT+<span class="attribute">CIPSERVER</span>=1,8080开启服务器，端口号8080</span><br><span class="line">8.AT+<span class="attribute">CIPSEND</span>=0,5AT+<span class="attribute">CIPSEND</span>=clientid,length</span><br><span class="line">9.AT+<span class="attribute">CIPSERVER</span>=0 关闭服务器</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="二、配置电脑客户端"><a href="#二、配置电脑客户端" class="headerlink" title="二、配置电脑客户端"></a>二、配置电脑客户端</h2><p>在网络测试助手中，设置协议类型，TCP客户端，设置远程主机地址为ESP8266的IP地址，远程主机端口为ESP8266的端口，最后点击连接，等待连接成功。</p><h2 id="三、数据收发"><a href="#三、数据收发" class="headerlink" title="三、数据收发"></a>三、数据收发</h2><p>当建立连接后，双方即可正常收发数据。</p><p>电脑在网络测试助手发送即可。</p><p>ESP8266发送数据需要在串口助手中先发送AT指令：AT+CIPSEND&#x3D;clientid,length，等待串口助手显示&gt;后，再输入要具体发送的内容。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、ESP8266配置&quot;&gt;&lt;a href=&quot;#一、ESP8266配置&quot; class=&quot;headerlink&quot; title=&quot;一、ESP8266配置&quot;&gt;&lt;/a&gt;一、ESP8266配置&lt;/h2&gt;&lt;p&gt;在串口助手中，通过AT指令配置ESP8266的AP模式。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="WIFI通信" scheme="https://shenlou99.github.io/categories/WIFI%E9%80%9A%E4%BF%A1/"/>
    
    
    <category term="ESP8266" scheme="https://shenlou99.github.io/tags/ESP8266/"/>
    
  </entry>
  
  <entry>
    <title>ESP8266通信——Station模式（8266客户端，电脑服务器，需要路由器中转）</title>
    <link href="https://shenlou99.github.io/2023/03/09/ESP8266%E9%80%9A%E4%BF%A1%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94Station%E6%A8%A1%E5%BC%8F/"/>
    <id>https://shenlou99.github.io/2023/03/09/ESP8266%E9%80%9A%E4%BF%A1%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94Station%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-03-09T08:13:35.000Z</published>
    <updated>2023-03-11T07:36:34.461Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、ESP8266配置"><a href="#一、ESP8266配置" class="headerlink" title="一、ESP8266配置"></a>一、ESP8266配置</h2><p>在串口助手中，通过AT指令配置ESP8266的station模式。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>AT测试AT是否OK</span><br><span class="line"><span class="number">2.</span>AT+RST软重启模组</span><br><span class="line"><span class="number">3.</span>AT+CWMODE=<span class="number">1</span>配置station模式</span><br><span class="line"><span class="number">4.</span>AT+CWLAP列出所有可连接热点</span><br><span class="line"><span class="number">5.</span>AT+CWJAP=<span class="string">&quot;SSID&quot;</span>,<span class="string">&quot;password&quot;</span>连接热点</span><br><span class="line"><span class="number">6.</span>AT+<span class="built_in">CIPMUX</span>=<span class="number">1</span>ESP8266 作为服务器做多支持 <span class="number">5</span> 个客户端的链接，<span class="type">id</span> 分配顺序是 <span class="number">0</span><span class="number">-4</span></span><br><span class="line"><span class="number">7.</span>AT+<span class="built_in">CIFSR</span>查看ESP8266的IP</span><br><span class="line"><span class="comment">//当电脑端服务器配置完成后，执行下面AT指令</span></span><br><span class="line"><span class="number">8.</span>AT+<span class="built_in">CIPSTART</span>=<span class="string">&quot;TCP&quot;</span>,<span class="string">&quot;IP地址&quot;</span>,端口号 ESP8266作为客户端，连接电脑服务器端</span><br><span class="line"><span class="number">9.</span>AT+<span class="built_in">CIPSEND</span>=<span class="number">0</span>,<span class="number">5</span>AT+<span class="built_in">CIPSEND</span>=clientid,length</span><br><span class="line"><span class="number">10.</span>AT+<span class="built_in">CIPCLOSE</span>关闭ESP8266与电脑的连接</span><br><span class="line"><span class="number">11.</span>AT+<span class="built_in">CIPQAP</span>关闭ESP8266与无线路由器的连接</span><br></pre></td></tr></table></figure><h2 id="二、配置电脑端服务器"><a href="#二、配置电脑端服务器" class="headerlink" title="二、配置电脑端服务器"></a>二、配置电脑端服务器</h2><p>在网络测试助手中，新建服务器，本地IP地址要确保与ESP8266的IP地址在同一网段，端口号设置8080，点击打开&#x2F;启动。</p><p>然后在ESP8266中，执行上面第8条的AT指令，等待连接成功。</p><p>如果失败，ESP8266多重启几次试试。</p><h2 id="三、数据收发"><a href="#三、数据收发" class="headerlink" title="三、数据收发"></a>三、数据收发</h2><p>当建立连接后，双方即可正常通信，收发数据。</p><p>电脑在网络测试助手发送即可。</p><p>ESP8266发送数据需要在串口助手中先发送AT指令：AT+CIPSEND&#x3D;clientid,length，等待串口助手显示&gt;后，再输入要具体发送的内容。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、ESP8266配置&quot;&gt;&lt;a href=&quot;#一、ESP8266配置&quot; class=&quot;headerlink&quot; title=&quot;一、ESP8266配置&quot;&gt;&lt;/a&gt;一、ESP8266配置&lt;/h2&gt;&lt;p&gt;在串口助手中，通过AT指令配置ESP8266的station模式。&lt;</summary>
      
    
    
    
    <category term="WIFI通信" scheme="https://shenlou99.github.io/categories/WIFI%E9%80%9A%E4%BF%A1/"/>
    
    
    <category term="ESP8266" scheme="https://shenlou99.github.io/tags/ESP8266/"/>
    
  </entry>
  
  <entry>
    <title>HAL库开发（二）——ADC与DMA</title>
    <link href="https://shenlou99.github.io/2023/03/02/HAL%E5%BA%93%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94ADC%E4%B8%8EDMA/"/>
    <id>https://shenlou99.github.io/2023/03/02/HAL%E5%BA%93%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94ADC%E4%B8%8EDMA/</id>
    <published>2023-03-02T09:43:15.000Z</published>
    <updated>2023-03-11T07:36:34.462Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、轮询法"><a href="#一、轮询法" class="headerlink" title="一、轮询法"></a>一、轮询法</h2><ol><li><p>开启RCC时钟</p></li><li><p>CubeMX进行ADC配置：</p><ul><li>通道</li><li>采用模式：一般选择连续采样模式</li><li>……如下图</li></ul><p><img src="/../images/ADC1.png" alt="ADC_CubeMX配置"></p></li><li><p>编写程序：驱动基本都自动生成好了，主要编写主函数。</p></li></ol><p>​在主函数中添加如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    HAL_ADC_Start(&amp;hadc1);</span><br><span class="line">HAL_ADC_PollForConversion(&amp;hadc1, <span class="number">10</span>);<span class="comment">//参数二：10是等待时间</span></span><br><span class="line">HAL_ADC_Stop(&amp;hadc1);</span><br><span class="line">    buf2 = HAL_ADC_GetValue(&amp;hadc1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、中断法"><a href="#二、中断法" class="headerlink" title="二、中断法"></a>二、中断法</h2><h4 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h4><p>在CubeMX配置ADC中断，即可在对应文件自动生成中断处理函数，在ADC.c下编写用户中断回调函数即可，如下：</p><p><img src="/../images/ADC2.png"></p><p><strong>需要注意的是：使用中断前，需要在主函数中添加如下代码（放在外设初始化函数之后，声明一次即可），确保中断使能，ADC开始工作：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__HAL_ADC_ENABLE_IT(&amp;hadc1,ADC_IT_EOC);</span><br><span class="line">HAL_ADC_Start(&amp;hadc1);</span><br></pre></td></tr></table></figure><h4 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h4><p>直接在主函数中的外设初始化函数之后，添加如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_ADC_Start_IT(&amp;hadc1);</span><br></pre></td></tr></table></figure><p>此函数比较特殊，调用一次就相当于打开了<strong>ADC转换完成中断</strong>和<strong>开启ADC采样</strong>。</p><p><em><strong>注意：当ADC配置开启连续采集模式时，在中断回调函数结尾需要加上ADC中断使能函数HAL_ADC_Start_IT(&amp;hadc)，来手动开启中断！！</strong></em></p><h2 id="三、DMA"><a href="#三、DMA" class="headerlink" title="三、DMA"></a>三、DMA</h2><p>dma有两种模式，分别为circular和normal。</p><ul><li>circular模式：dma的circular模式只需要调用一次dma开启函数，dma就会持续的搬运数据，提高了数据的刷新速度，但是在circular模式下，不管adc新的一轮数据采集是否完成，有可能直接将旧数据搬运走。</li><li>normal模式：该模式下，dma启动函数调用一次，dma通道只会搬运一次数据，这样每调一次dma启动函数，dma只会搬运一次数据，等待数据传输完成后再次开启dma启动函数，这样更能保证adc数据采集的可靠性。</li></ul><h4 id="Circular模式："><a href="#Circular模式：" class="headerlink" title="Circular模式："></a>Circular模式：</h4><p>在CubeMX配置完ADC的DMA功能后，需要在主函数中调用如下代码（一次就行，即外设初始化后）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint16_t</span> AD_value=<span class="number">0</span>;</span><br><span class="line"><span class="type">float</span> f_AD_value;</span><br><span class="line"></span><br><span class="line">**************</span><br><span class="line"><span class="comment">//外设初始化</span></span><br><span class="line">**************</span><br><span class="line">    </span><br><span class="line">HAL_ADC_Start_DMA(&amp;hadc1,(<span class="type">uint32_t</span>*)&amp;AD_value,<span class="keyword">sizeof</span>(AD_value));</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，CubeMX中配置完DMA，会在中断文件（stm32f4xx_it.c）中自动生成DMA中断处理函数，用户在此编写处理程序或中断回调函数中编写都可。</p><p>如下：</p><p><img src="/../images/ADC3.png"></p><p>加上标志位检测，是为了确保DMA在Circular模式下数据不发生遗漏，错误。因此，在normal模式下，一般不加标志检测。</p><h4 id="normal模式"><a href="#normal模式" class="headerlink" title="normal模式"></a>normal模式</h4><p>与Circular模式配置基本相似，区别在于采集模式（ContinuousConvMode）的选择以及是否在中断处理中是否添加标志检测。</p><p>参考链接：<a href="https://blog.csdn.net/weixin_46461874/article/details/128686185?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-5-128686185-blog-117872009.pc_relevant_3mothn_strategy_recovery&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-5-128686185-blog-117872009.pc_relevant_3mothn_strategy_recovery&utm_relevant_index=8">https://blog.csdn.net/weixin_46461874/article/details/128686185?spm=1001.2101.3001.6650.5&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EYuanLiJiHua%7EPosition-5-128686185-blog-117872009.pc_relevant_3mothn_strategy_recovery&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EYuanLiJiHua%7EPosition-5-128686185-blog-117872009.pc_relevant_3mothn_strategy_recovery&amp;utm_relevant_index=8</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、轮询法&quot;&gt;&lt;a href=&quot;#一、轮询法&quot; class=&quot;headerlink&quot; title=&quot;一、轮询法&quot;&gt;&lt;/a&gt;一、轮询法&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;开启RCC时钟&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;CubeMX进行ADC配置：&lt;/p&gt;
&lt;ul&gt;
</summary>
      
    
    
    
    <category term="HAL库" scheme="https://shenlou99.github.io/categories/HAL%E5%BA%93/"/>
    
    
    <category term="stm32,ADC,DMA" scheme="https://shenlou99.github.io/tags/stm32-ADC-DMA/"/>
    
  </entry>
  
  <entry>
    <title>HAL库开发（一）——回调函数</title>
    <link href="https://shenlou99.github.io/2023/03/02/HAL%E5%BA%93%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"/>
    <id>https://shenlou99.github.io/2023/03/02/HAL%E5%BA%93%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</id>
    <published>2023-03-02T09:17:23.000Z</published>
    <updated>2023-03-11T07:36:34.462Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、为什么要回调函数"><a href="#一、为什么要回调函数" class="headerlink" title="一、为什么要回调函数"></a>一、为什么要回调函数</h2><p><em><strong>传统标准库的中断：在中断中进行数据处理，如果数据量比较大，再加上潜在的延时，极大的占用了CPU的时间，一直处在中断中，其他中断无法执行，主函数无法进行。</strong></em></p><p><strong>因此，在HAL库中，引入回调函数，工作方式如下图。即当发生中断时，cpu依旧进入中断处理函数（即中断入口），但中断处理函数不做数据处理，而是标记中断回调函数，退出中断，间接调用回调函数，然后在中断回调函数里执行数据的处理。好处就是，这样做给其他中断有了中断时间，不浪费中断资源。</strong></p><p><img src="/../images/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B01.png" alt="查询法与中断法"></p><p><img src="/../images/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B02.png" alt="回调函数处理过程"></p><h2 id="二、回调函数的使用"><a href="#二、回调函数的使用" class="headerlink" title="二、回调函数的使用"></a>二、回调函数的使用</h2><p>在CubeMX配置好后，相应的中断处理函数会在stm32f4xx_it.c中自动配置好，基本形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DMA2_Stream0_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN DMA2_Stream0_IRQn 0 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END DMA2_Stream0_IRQn 0 */</span></span><br><span class="line">  HAL_DMA_IRQHandler(&amp;hdma_adc1);</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN DMA2_Stream0_IRQn 1 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END DMA2_Stream0_IRQn 1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在中断处理函数中都会指向：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_XXX_IRQHandler(&amp;XXX);</span><br></pre></td></tr></table></figure><p>这个函数就会间接调用回调函数。回调函数在相应HAL驱动库的C文件中，前面有__week定义，其意义在于当用户有自己定义的回调函数时，优先执行用户的回调函数，用户回调函数名需与官方回调函数名一致。</p><p>形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__weak <span class="type">void</span> <span class="title function_">HAL_UART_RxCpltCallback</span><span class="params">(UART_HandleTypeDef *huart)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Prevent unused argument(s) compilation warning */</span></span><br><span class="line">  UNUSED(huart);</span><br><span class="line">  <span class="comment">/* <span class="doctag">NOTE:</span> This function should not be modified, when the callback is needed,</span></span><br><span class="line"><span class="comment">           the HAL_UART_RxCpltCallback could be implemented in the user file</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关于用户对于数据的处理以及一些自定义的需求，可以在此中断回调函数中编写。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、为什么要回调函数&quot;&gt;&lt;a href=&quot;#一、为什么要回调函数&quot; class=&quot;headerlink&quot; title=&quot;一、为什么要回调函数&quot;&gt;&lt;/a&gt;一、为什么要回调函数&lt;/h2&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;传统标准库的中断：在中断中进行数据处理，如果数据量比</summary>
      
    
    
    
    <category term="HAL" scheme="https://shenlou99.github.io/categories/HAL/"/>
    
    
    <category term="stm32,HAL" scheme="https://shenlou99.github.io/tags/stm32-HAL/"/>
    
  </entry>
  
  <entry>
    <title>物联网网络协议——MQTT协议（一）</title>
    <link href="https://shenlou99.github.io/2023/02/17/%E7%89%A9%E8%81%94%E7%BD%91%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E2%80%94%E2%80%94MQTT%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://shenlou99.github.io/2023/02/17/%E7%89%A9%E8%81%94%E7%BD%91%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E2%80%94%E2%80%94MQTT%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2023-02-17T06:10:58.000Z</published>
    <updated>2023-03-11T07:36:34.470Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>MQTT通讯协议是定义在TCP协议之上的：</p><ol><li>TCP通讯协议可以理解为接近底层，保障双向通信。</li><li>报障电话接通是TCP，我们和对方说的方言是MQTT。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h2&gt;&lt;p&gt;MQTT通讯协议是定义在TCP协议之上的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;TCP通讯协议可以理解为接近底层，保障双向通信。&lt;/l</summary>
      
    
    
    
    <category term="网络协议" scheme="https://shenlou99.github.io/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="MQTT" scheme="https://shenlou99.github.io/tags/MQTT/"/>
    
  </entry>
  
  <entry>
    <title>判断一帧数据接收完成的常见方法</title>
    <link href="https://shenlou99.github.io/2023/02/17/%E5%88%A4%E6%96%AD%E4%B8%80%E5%B8%A7%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E5%AE%8C%E6%88%90%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://shenlou99.github.io/2023/02/17/%E5%88%A4%E6%96%AD%E4%B8%80%E5%B8%A7%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E5%AE%8C%E6%88%90%E7%9A%84%E6%96%B9%E6%B3%95/</id>
    <published>2023-02-17T01:04:12.000Z</published>
    <updated>2023-03-11T07:36:34.468Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、延时检测"><a href="#一、延时检测" class="headerlink" title="一、延时检测"></a>一、延时检测</h2><h4 id="使用定时器判断"><a href="#使用定时器判断" class="headerlink" title="使用定时器判断"></a>使用定时器判断</h4><p>这种方法建立在两帧数据不可能连续发送的基础上，也是modbus判断帧结束的方式，在接受到第一个字节的时候打开定时器，如果继续接收到数据则更新定时器，在被设定时间内没有接收到数据则定时器超时，标志一帧数据接收完毕。</p><p><img src="/../images/%E5%AE%9A%E6%97%B6%E5%99%A8%E5%B8%A7%E6%95%B0%E6%8D%AE%E5%88%A4%E6%96%AD%E9%80%BB%E8%BE%91%E6%A1%86%E5%9B%BE.png" alt="定时器帧数据判断逻辑框图"></p><h4 id="关于定时器的设定时间有几个问题："><a href="#关于定时器的设定时间有几个问题：" class="headerlink" title="关于定时器的设定时间有几个问题："></a>关于定时器的设定时间有几个问题：</h4><ul><li>其一是如果定时器超时时间大于发送两帧数据的时间间隔，则接收到的一帧数据实际上是几帧，更可能定时器无法超时，一直处于接收状态。</li><li>其二是如果定时器超时小于发生两个字节的时间间隔，则在接收到1个字节定时器就超时了。</li></ul><p>我们于是只能设定一个尽量小但又不影响接收连续字节的时间，例如ModBus通信时规定发送完一组命令必须间隔3.5个字符时间间隔再发送下一组新命令，这里规定的便是定时器的超时时间。</p><h4 id="关于时间的计算"><a href="#关于时间的计算" class="headerlink" title="关于时间的计算"></a>关于时间的计算</h4><p>首先，1个字符窗口包含起始位，数据位，校验位，停止位，其中有些位长度不一定，这里我们按1+8+1+1来计算。波特率表示的意思是在1000ms内可以传送的位数，设3.5个字节所用时间为X，波特率为9600则:<br> 3.5*11 &#x2F; X  &#x3D; 9600 &#x2F; 1000<br> X &#x3D; 4.010416666666667 ms<br> X代表的意思是两帧数据间隔时间至少为此，我们程序的超时定时器可以设定为4ms。同时也知道波特率变化是会影响该值。</p><h2 id="二、解析协议方式"><a href="#二、解析协议方式" class="headerlink" title="二、解析协议方式"></a>二、解析协议方式</h2><p>该方式便是通过协议中的保存的长度、包头、包尾等信息来判断帧接收完成。通常是将数据保存在一个循环buffer中，从中去找对应信息，根据信息判断取出一帧数据还是继续等待。</p><h2 id="三、空闲中断"><a href="#三、空闲中断" class="headerlink" title="三、空闲中断"></a>三、空闲中断</h2><p>在STM32中有个串口空闲中断，在总线由忙碌转为空闲时(RXNE被置为)参数这个中断，我们可以利用这个中断来知道一帧传输接收，需要进行处理。</p><h5 id="更多信息请查看："><a href="#更多信息请查看：" class="headerlink" title="更多信息请查看："></a>更多信息请查看：</h5><p><a href="https://www.jianshu.com/p/bb0ab9a58eff#:~:text=%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%B2%E5%8F%A3%E6%8E%A5%E6%94%B6%E5%AE%8C%E6%88%90%E4%B8%80%E5%B8%A7%E6%95%B0%E6%8D%AE%201%201%20%E4%BD%BF%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E5%88%A4%E6%96%AD%20%E8%BF%99%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%BB%BA%E7%AB%8B%E5%9C%A8%E4%B8%A4%E5%B8%A7%E6%95%B0%E6%8D%AE%E4%B8%8D%E5%8F%AF%E8%83%BD%E8%BF%9E%E7%BB%AD%E5%8F%91%E9%80%81%E7%9A%84%E5%9F%BA%E7%A1%80%E4%B8%8A%EF%BC%8C%E4%B9%9F%E6%98%AFmodbus%E5%88%A4%E6%96%AD%E5%B8%A7%E7%BB%93%E6%9D%9F%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%9C%A8%E6%8E%A5%E6%94%B6%E5%88%B0%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AD%97%E8%8A%82%E7%9A%84%E6%97%B6%E5%80%99%E6%89%93%E5%BC%80%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%8C%E5%A6%82%E6%9E%9C%E7%BB%A7%E7%BB%AD%E6%8E%A5%E6%94%B6%E5%88%B0%E6%95%B0%E6%8D%AE%E5%88%99%E6%9B%B4%E6%96%B0%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%8C%E5%9C%A8%E8%A2%AB%E8%AE%BE%E5%AE%9A%E6%97%B6%E9%97%B4%E5%86%85%E6%B2%A1%E6%9C%89%E6%8E%A5%E6%94%B6%E5%88%B0%E6%95%B0%E6%8D%AE%E5%88%99%E5%AE%9A%E6%97%B6%E5%99%A8%E8%B6%85%E6%97%B6%E3%80%82%20enter%20image%20description,%E9%80%9A%E5%B8%B8%E6%98%AF%E5%B0%86%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%BE%AA%E7%8E%AFbuffer%E4%B8%AD%EF%BC%8C%E4%BB%8E%E4%B8%AD%E5%8E%BB%E6%89%BE%E5%AF%B9%E5%BA%94%E4%BF%A1%E6%81%AF%EF%BC%8C%E6%A0%B9%E6%8D%AE%E4%BF%A1%E6%81%AF%E5%88%A4%E6%96%AD%E5%8F%96%E5%87%BA%E4%B8%80%E5%B8%A7%E6%95%B0%E6%8D%AE%E8%BF%98%E6%98%AF%E7%BB%A7%E7%BB%AD%E7%AD%89%E5%BE%85%E3%80%82%203%203%20%E7%A9%BA%E9%97%B2%E4%B8%AD%E6%96%AD%20%E5%9C%A8STM32%E4%B8%AD%E6%9C%89%E4%B8%AA%E4%B8%B2%E5%8F%A3%E7%A9%BA%E9%97%B2%E4%B8%AD%E6%96%AD%EF%BC%8C%E5%9C%A8%E6%80%BB%E7%BA%BF%E7%94%B1%E5%BF%99%E7%A2%8C%E8%BD%AC%E4%B8%BA%E7%A9%BA%E9%97%B2%E6%97%B6%20%28RXNE%E8%A2%AB%E7%BD%AE%E4%B8%BA%29%E5%8F%82%E6%95%B0%E8%BF%99%E4%B8%AA%E4%B8%AD%E6%96%AD%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E5%88%A9%E7%94%A8%E8%BF%99%E4%B8%AA%E4%B8%AD%E6%96%AD%E6%9D%A5%E7%9F%A5%E9%81%93%E4%B8%80%E5%B8%A7%E4%BC%A0%E8%BE%93%E6%8E%A5%E6%94%B6%EF%BC%8C%E9%9C%80%E8%A6%81%E8%BF%9B%E8%A1%8C%E5%A4%84%E7%90%86%E3%80%82%20%E4%B8%8B%E9%9D%A2%E6%98%AFSMT32L151%E7%9A%84%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%8C%E9%A6%96%E5%85%88%E5%9C%A8%E4%B8%B2%E5%8F%A3%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%EF%BC%8C%E4%B9%9F%E4%BD%BF%E8%83%BD%E7%A9%BA%E9%97%B2%E4%B8%AD%E6%96%AD%20">如何判断串口接收完成一帧数据</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、延时检测&quot;&gt;&lt;a href=&quot;#一、延时检测&quot; class=&quot;headerlink&quot; title=&quot;一、延时检测&quot;&gt;&lt;/a&gt;一、延时检测&lt;/h2&gt;&lt;h4 id=&quot;使用定时器判断&quot;&gt;&lt;a href=&quot;#使用定时器判断&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="数据帧" scheme="https://shenlou99.github.io/categories/%E6%95%B0%E6%8D%AE%E5%B8%A7/"/>
    
    
    <category term="数据帧" scheme="https://shenlou99.github.io/tags/%E6%95%B0%E6%8D%AE%E5%B8%A7/"/>
    
  </entry>
  
  <entry>
    <title>单片机选型</title>
    <link href="https://shenlou99.github.io/2023/02/15/%E5%8D%95%E7%89%87%E6%9C%BA%E9%80%89%E5%9E%8B/"/>
    <id>https://shenlou99.github.io/2023/02/15/%E5%8D%95%E7%89%87%E6%9C%BA%E9%80%89%E5%9E%8B/</id>
    <published>2023-02-15T06:29:14.000Z</published>
    <updated>2023-03-11T07:36:34.470Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单片机选型"><a href="#单片机选型" class="headerlink" title="单片机选型"></a>单片机选型</h2><p>一般来说在选取单片机时从下面几个方面考虑：性能、存储器、运行速度、I&#x2F;O口、定时&#x2F;计数器、串行接口、模拟电路功能、工作电压、功耗、封装形式、抗干扰性、保密性。</p><p>除了以上的一些方面外，还有一些最基本的条件，比如：中断源的数量和优先级、工作温度范围、有没有低电压检测功能、单片机内有无时钟振荡器、有无上电复位功能等。</p><p>在开发过程中还要考虑开发工具、编程器、开发成本、开发人员的适应性、技术支持和服务等因素。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;单片机选型&quot;&gt;&lt;a href=&quot;#单片机选型&quot; class=&quot;headerlink&quot; title=&quot;单片机选型&quot;&gt;&lt;/a&gt;单片机选型&lt;/h2&gt;&lt;p&gt;一般来说在选取单片机时从下面几个方面考虑：性能、存储器、运行速度、I&amp;#x2F;O口、定时&amp;#x2F;计数器、串行接</summary>
      
    
    
    
    <category term="选型" scheme="https://shenlou99.github.io/categories/%E9%80%89%E5%9E%8B/"/>
    
    
    <category term="单片机选型" scheme="https://shenlou99.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA%E9%80%89%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>单片机定时器介绍</title>
    <link href="https://shenlou99.github.io/2023/02/13/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BB%8B%E7%BB%8D/"/>
    <id>https://shenlou99.github.io/2023/02/13/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BB%8B%E7%BB%8D/</id>
    <published>2023-02-13T08:05:24.000Z</published>
    <updated>2023-03-11T07:36:34.468Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定时器介绍"><a href="#定时器介绍" class="headerlink" title="定时器介绍"></a>定时器介绍</h2><h4 id="基本知识："><a href="#基本知识：" class="headerlink" title="基本知识："></a>基本知识：</h4><p><strong>1.CPU 时序的有关知识</strong></p><p>①振荡周期：为单片机提供定时信号的振荡源的周期（晶振周期或外加振荡</p><p>周期）。</p><p>②状态周期：2 个振荡周期为 1 个状态周期，用 S 表示。振荡周期又称 S 周</p><p>期或时钟周期。</p><p>③机器周期：1 个机器周期含 6 个状态周期，12 个振荡周期。</p><p>④指令周期：完成 1 条指令所占用的全部时间，它以机器周期为单位。</p><p>例如：外接晶振为 12MHz 时，51 单片机相关周期的具体值为：</p><p>振荡周期&#x3D;1&#x2F;12us;</p><p>状态周期&#x3D;1&#x2F;6us;</p><p>机器周期&#x3D;1us;</p><p>指令周期&#x3D;1~4us;</p><p><strong>有了定时器&#x2F;计数器之后，可以增加单片机的效率，一些简单的重复加 1 的工作可以交给定时器&#x2F;计数器处理。CPU 转而处理一些复杂的事情。同时可以实现精确定时作用。</strong></p><h4 id="定时器原理："><a href="#定时器原理：" class="headerlink" title="定时器原理："></a>定时器原理：</h4><p>前面我们介绍过机器周期的概念，它是 CPU 完成一个基本操作所需要的时间。其计算公式是：机器周期&#x3D;1&#x2F;单片机的时钟频率。51 单片机内部时钟频率是外部时钟的 12 分频，也就是说当外部晶振的频率输入到单片机里面的时候要进行 12分频。比如说你用的是 12MHZ 晶振，那么单片机内部的时钟频率就是 12&#x2F;12MHZ，当你使用 12MHZ 的外部晶振的时候，机器周期&#x3D;1&#x2F;1M&#x3D;1us。如果我们想定时 1ms的初值是多少呢？1ms&#x2F;1us&#x3D;1000。也就是要计数 1000 个，初值&#x3D;65535-1000+1（因为实际上计数器计数到 65536（2 的 16 次方）才溢出，所以后面要加 1）&#x3D;64536&#x3D;FC18H，所以初值即为 THx&#x3D;0XFC，TLx&#x3D;0X18。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;定时器介绍&quot;&gt;&lt;a href=&quot;#定时器介绍&quot; class=&quot;headerlink&quot; title=&quot;定时器介绍&quot;&gt;&lt;/a&gt;定时器介绍&lt;/h2&gt;&lt;h4 id=&quot;基本知识：&quot;&gt;&lt;a href=&quot;#基本知识：&quot; class=&quot;headerlink&quot; title=&quot;基本知</summary>
      
    
    
    
    <category term="定时器" scheme="https://shenlou99.github.io/categories/%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
    
    
    <category term="单片机定时器" scheme="https://shenlou99.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>串口波特率的产生</title>
    <link href="https://shenlou99.github.io/2023/02/13/%E4%B8%B2%E5%8F%A3%E6%B3%A2%E7%89%B9%E7%8E%87%E7%9A%84%E4%BA%A7%E7%94%9F/"/>
    <id>https://shenlou99.github.io/2023/02/13/%E4%B8%B2%E5%8F%A3%E6%B3%A2%E7%89%B9%E7%8E%87%E7%9A%84%E4%BA%A7%E7%94%9F/</id>
    <published>2023-02-13T07:16:41.000Z</published>
    <updated>2023-03-11T07:36:34.467Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、stc单片机串口波特率的产生"><a href="#一、stc单片机串口波特率的产生" class="headerlink" title="一、stc单片机串口波特率的产生"></a>一、stc单片机串口波特率的产生</h2><h4 id="1-stc单片机"><a href="#1-stc单片机" class="headerlink" title="1.stc单片机"></a>1.stc单片机</h4><h5 id="①传统51单片机："><a href="#①传统51单片机：" class="headerlink" title="①传统51单片机："></a>①传统51单片机：</h5><p>传统单片机是12T的，就是说12个时钟周期（晶振周期，例如12M的，周期是1&#x2F;12M，单位秒），机器做一个指令周期，刚好就是1&#x2F;12M*12&#x3D;1us。</p><p>而串口的波特率是通过定时器产生的，当SMOD&#x3D;1时，K&#x3D;2，波特率加倍，公式为：</p><p><strong>波特率&#x3D;K×11059200&#x2F;（32×12×(256-TH1)）</strong>，所以即使令TH1&#x3D;0xff，所得波特率最大只能为57600,</p><p><em><strong>所以，传统单片机波特率不能设置115200，一般用9600！</strong></em></p><h5 id="②新型stc单片机："><a href="#②新型stc单片机：" class="headerlink" title="②新型stc单片机："></a>②新型stc单片机：</h5><p>新型单片机，如stc12，stc8h等都支持了1T模式，即1个机器周期等于1个振荡周期。</p><p> 1T 模式 (不分频) —— 1个系统基本时钟，执行一个动作；<br> 12T模式(12分频) —— 12个系统基本时钟，执行一个动作；</p><p>因此，12T模式和1T模式执行相同次数的动作，12T模式需要12倍的时间，<br>即，两个模式执行一个动作需要的时间不同，12T模式需要更多的时间，<br>即，1T模式的工作速度比12T模式的工作速度快。</p><p>此时，1T模式的<strong>波特率&#x3D;2（SMOD次方）x SYSclk&#x2F;（12 x 32 x（256-（TH1，TL1）））</strong>,不同定时器计算公式有略微差别！</p><p>例如：stc8H单片机，其串口1波特率发生模式有两种：</p><ol><li><p>串口1模式0和模式2的时候，波特率是固定的，由主频决定，计算公式为<strong>波特率&#x3D;SYSclk&#x2F;12</strong>。</p></li><li><p>串口1模式1和模式3的时候，波特率由定时器发生。计算公式如下图：</p><p><img src="/../images/%E4%B8%B2%E5%8F%A3%E6%B3%A2%E7%89%B9%E7%8E%87%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F.png" alt="串口波特率计算公式"></p></li></ol><h5 id="以定时器为例："><a href="#以定时器为例：" class="headerlink" title="以定时器为例："></a>以定时器为例：</h5><p>【定时器工作原理】定时器从初值开始计数加1，一直加到溢出，产生定时器中断。</p><p>【定时器配置】现在有一个使用24MHz晶振的单片机，使用定时器0的16位工作模式，产生1000Hz的频率，即1ms产生一次中断。</p><p>【 1T 】TH0 &#x3D; 0xA2; TL0 &#x3D; 0x40; 定时器从A240计数到FFFF产生中断。<br>【12T】TH0 &#x3D; 0xF8; TL0 &#x3D; 0x30; 定时器从F830计数到FFFF产生中断。</p><p>定时器1T模式计数FFFF - A240 &#x3D; 23999次产生中断，定时器12T模式计数FFFF - F830 &#x3D; 1999次（1999*12&#x3D;23999）产生中断，所以实际上计数产生中断的时间是一样的。</p><p>所以，<br>当定时器产生中断的频率相同时，定时器的初值是不一样的，并且1T模式的初值比12T的初值要小，加到溢出的值要更多，但是两者溢出产生中断的时间是相等的。<br>当初值相同时，1T更快产生中断，12T需要12倍的时间才能产生中断。</p><h2 id="STM32"><a href="#STM32" class="headerlink" title="STM32"></a>STM32</h2><p>对于STM32来说，其时钟树更为复杂。以stm32f103为例，USART1挂载在APB2上，最大频率为72MHz；USART2&#x2F;3挂载在APB1上，最大频率为36MHz。而STM32的USART的通信速率与USART时钟息息相关，详细可见stm32f103数据手册&#x2F;参考手册。</p><p>STM32的串口波特率是通过波特比率寄存器（USART_BRR)设置的，在STM32F103XX中文参考手册 中有这样一段介绍：</p><p><img src="/../images/stm32%E4%B8%B2%E5%8F%A3%E6%B3%A2%E7%89%B9%E7%8E%87.png" alt="stm32串口波特率"></p><p>我们得知：stm32的波特比率寄存器USART_BRR支持分数设置，精确度因此提高。在手册中给出了波特率的计算公式：</p><p><img src="/../images/stm32%E4%B8%B2%E5%8F%A3%E6%B3%A2%E7%89%B9%E7%8E%87%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F.png"></p><p>例如：</p><p>假设我们需要实现2.5Mbit&#x2F;s的通信速率，由上我们知道只有STM32的USART1可以实现该通信速率。</p><p>USART1的外设时钟(fck)为72MHz，fck &#x2F; 波特率 &#x3D; 16 * USARTDIV  &#x3D;&#x3D;&#x3D;》 USARTDIV &#x3D; 1.8，将整数部分1 &#x3D; 0x01写入USART_BRR的位15：4，小数部分（0.8 * 16） &#x3D; 12.5 ≈ 13 &#x3D; 0xD写入USART_BRR的位3：0即可。USART_BRR的值为0x1D；值得注意的是：使用库函数不用自行写入USART_BRR的值。</p><p>更详细内容可参考下方文章：</p><p><a href="http://news.eeworld.com.cn/mcu/ic520335.html#:~:text=%E3%80%80%E3%80%80STM32%E7%9A%84%E4%B8%B2%E5%8F%A3%E6%B3%A2%E7%89%B9%E7%8E%87%E6%98%AF%E9%80%9A%E8%BF%87%20%E6%B3%A2%E7%89%B9%E6%AF%94%E7%8E%87%E5%AF%84%E5%AD%98%E5%99%A8%28USART_BRR%29%20%E8%AE%BE%E7%BD%AE%E7%9A%84%EF%BC%8C%E5%9C%A8%20STM32F103XX%E4%B8%AD%E6%96%87%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C,%E4%B8%AD%E6%9C%89%E8%BF%99%E6%A0%B7%E4%B8%80%E6%AE%B5%E4%BB%8B%E7%BB%8D%EF%BC%9A%20%E3%80%80%E3%80%80%E6%88%91%E4%BB%AC%E5%BE%97%E7%9F%A5%EF%BC%9ASTM32%E7%9A%84%20%E6%B3%A2%E7%89%B9%E6%AF%94%E7%8E%87%E5%AF%84%E5%AD%98%E5%99%A8USART_BRR%20%E6%94%AF%E6%8C%81%E5%88%86%E6%95%B0%E8%AE%BE%E7%BD%AE%EF%BC%8C%E7%B2%BE%E7%A1%AE%E5%BA%A6%E5%9B%A0%E6%AD%A4%E6%8F%90%E9%AB%98%E3%80%82">STM32之关于USART以及波特率的一些思考-电子工程世界</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、stc单片机串口波特率的产生&quot;&gt;&lt;a href=&quot;#一、stc单片机串口波特率的产生&quot; class=&quot;headerlink&quot; title=&quot;一、stc单片机串口波特率的产生&quot;&gt;&lt;/a&gt;一、stc单片机串口波特率的产生&lt;/h2&gt;&lt;h4 id=&quot;1-stc单片机&quot;</summary>
      
    
    
    
    <category term="波特率" scheme="https://shenlou99.github.io/categories/%E6%B3%A2%E7%89%B9%E7%8E%87/"/>
    
    
    <category term="波特率的产生" scheme="https://shenlou99.github.io/tags/%E6%B3%A2%E7%89%B9%E7%8E%87%E7%9A%84%E4%BA%A7%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>CSharp网络编程——TCP/IP编程</title>
    <link href="https://shenlou99.github.io/2023/02/10/CSharp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94TCP-IP/"/>
    <id>https://shenlou99.github.io/2023/02/10/CSharp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94TCP-IP/</id>
    <published>2023-02-10T05:59:00.000Z</published>
    <updated>2023-03-11T07:36:34.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Socket网络编程"><a href="#一、Socket网络编程" class="headerlink" title="一、Socket网络编程"></a>一、Socket网络编程</h2><p>Socket：套接字，用于描述IP地址和端口，是一个通信链的句柄，用以实现计算机之间通信。</p><p>有了服务器的IP地址和端口号，客户端才知道需要链接服务器哪个程序，建立socket连接。</p><h2 id="二、TCP-x2F-UDP协议"><a href="#二、TCP-x2F-UDP协议" class="headerlink" title="二、TCP&#x2F;UDP协议"></a>二、TCP&#x2F;UDP协议</h2><ul><li>TCP协议：安全稳定，效率低，不会发生数据丢失。要求必须有一个服务器，因为要经历三次握手过程：<ul><li>1）客户端请求；</li><li>2）服务器响应；</li><li>3）客户端得知服务器响应</li></ul></li><li>UDP协议：效率高，但有可能发生数据丢失。不用经过服务器响应是否有空闲接收消息，自主传输。</li></ul><h2 id="三、创建客户端"><a href="#三、创建客户端" class="headerlink" title="三、创建客户端"></a>三、创建客户端</h2><ol><li>创建负责通信的socket</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socketSend = <span class="keyword">new</span> Socket(AddressFamily.InterNetwork,SocketType,Stream,ProtocolType.Tcp);</span><br></pre></td></tr></table></figure><ol start="2"><li>获取将要连接的服务器的IP和程序的端口</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IPAddress ip = IPAddress.Parse(txtServer.Text.Trim());</span><br><span class="line">   ↓</span><br><span class="line"> 控件名</span><br><span class="line">IPEndPoint point = <span class="keyword">new</span> IPEndPoint(ip,Convert.ToInt32(txtPort.Text.Trim()));</span><br><span class="line">↓</span><br><span class="line">   控件名</span><br></pre></td></tr></table></figure><ol start="3"><li>建立连接</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">socketSend.Connect(point);</span><br><span class="line">ShowMsg(<span class="string">&quot;发送成功&quot;</span>);</span><br></pre></td></tr></table></figure><ol start="4"><li>给服务器发送消息</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = txtmessage.Text.Trim();<span class="comment">//获取要发送的消息</span></span><br><span class="line">   ↓</span><br><span class="line">   控件名</span><br><span class="line"><span class="built_in">byte</span>[] buffer = Encoding.UTF8.GetBytes(str);<span class="comment">//转成字节数组</span></span><br><span class="line">socketSend.Send(buffer);<span class="comment">//发送字节数组</span></span><br></pre></td></tr></table></figure><ol start="5"><li>不停的接收服务器发来的消息</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">注意：接收也要写在<span class="keyword">while</span>(<span class="literal">true</span>)里面，需要一直接受客户端发过来的消息，并且需要创建后台新线程来执行它。</span><br><span class="line"><span class="built_in">byte</span>[] buffer = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">2</span>];<span class="comment">//定义一个字节数组</span></span><br><span class="line"><span class="built_in">int</span> r = socketSend.Receive(buffer);<span class="comment">//接收字节数组放入buffer中，返回接收字节数</span></span><br><span class="line"><span class="keyword">if</span>(r == <span class="number">0</span>) <span class="keyword">return</span>;<span class="comment">//如果没有信息接收，结束该循环</span></span><br><span class="line"><span class="built_in">string</span> str = Encoding.UTF8.GetString(buffer,<span class="number">0</span>,r);<span class="comment">//将接收的字节数组转成字符串</span></span><br><span class="line">ShowMsg(socketSend.RemoteEndPoint.Tostring() + <span class="string">&quot;:&quot;</span> + str);</span><br></pre></td></tr></table></figure><h2 id="四、实例"><a href="#四、实例" class="headerlink" title="四、实例"></a>四、实例</h2><h4 id="连接服务器："><a href="#连接服务器：" class="headerlink" title="连接服务器："></a>连接服务器：</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">region</span> 连接服务器端</span></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">btn_wangkouOPEN_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           btn_wangkouOPEN.Enabled = <span class="literal">false</span>;</span><br><span class="line">           <span class="comment">//创建客户端Socket</span></span><br><span class="line">           ClientSocket = <span class="keyword">new</span> Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);</span><br><span class="line"></span><br><span class="line">           rtb_textshow.Text += <span class="string">&quot;正在连接......&quot;</span> + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">           <span class="comment">//IP和端口号转换格式</span></span><br><span class="line">           IPAddress ServerIP = IPAddress.Parse(tb_ipaddress.Text);</span><br><span class="line">           <span class="built_in">int</span> Port = <span class="built_in">int</span>.Parse(tb_ipport.Text);</span><br><span class="line">           <span class="comment">//IP和端口号绑定</span></span><br><span class="line">           IPEndPoint ServerAddress = <span class="keyword">new</span> IPEndPoint(ServerIP, Port);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">try</span></span><br><span class="line">           &#123;</span><br><span class="line">               <span class="comment">//客户端Socket连接服务器地址</span></span><br><span class="line">               ClientSocket.Connect(ServerAddress);</span><br><span class="line">               SFlag = <span class="number">1</span>;  <span class="comment">//若连接成功将标志设置为1</span></span><br><span class="line">               rtb_textshow.Text += DateTime.Now.ToString(<span class="string">&quot;yy-MM-dd hh:mm:ss  &quot;</span>) + tb_ipaddress.Text + <span class="string">&quot;连接成功&quot;</span> + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">               btn_wangkouOPEN.Enabled = <span class="literal">false</span>;     <span class="comment">//禁止操作连接按钮</span></span><br><span class="line"></span><br><span class="line">               <span class="comment">//开启一个线程接收数据</span></span><br><span class="line">               th1 = <span class="keyword">new</span> Thread(Receive);</span><br><span class="line">               th1.IsBackground = <span class="literal">true</span>;</span><br><span class="line">               th1.Start(ClientSocket);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">catch</span></span><br><span class="line">           &#123;</span><br><span class="line">               MessageBox.Show(<span class="string">&quot;服务器未打开&quot;</span>);</span><br><span class="line">               btn_wangkouOPEN.Enabled = <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="meta">#<span class="keyword">region</span></span></span><br><span class="line">           <span class="comment">/*****</span></span><br><span class="line"><span class="comment">           serverIP = IPAddress.Parse(tb_ipaddress.Text);</span></span><br><span class="line"><span class="comment">           try</span></span><br><span class="line"><span class="comment">           &#123;</span></span><br><span class="line"><span class="comment">               serverFullAddr = new IPEndPoint(serverIP, int.Parse(tb_ipport.Text));//设置IP，端口</span></span><br><span class="line"><span class="comment">               ClientSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);</span></span><br><span class="line"><span class="comment">               //指定本地主机地址和端口号</span></span><br><span class="line"><span class="comment">               ClientSocket.Connect(serverFullAddr);</span></span><br><span class="line"><span class="comment">               //btnConn.Enabled = false;</span></span><br><span class="line"><span class="comment">               //rtb_textshow.Text = &quot;连接服务器成功。。。。&quot;;</span></span><br><span class="line"><span class="comment">               MessageBox.Show(&quot;连接服务器成功！&quot;);</span></span><br><span class="line"><span class="comment">               btn_wangkouCLOSE.Enabled = true;</span></span><br><span class="line"><span class="comment">               //sock.Close();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           &#125;</span></span><br><span class="line"><span class="comment">           catch (Exception ee)</span></span><br><span class="line"><span class="comment">           &#123;</span></span><br><span class="line"><span class="comment">               btn_wangkouOPEN.Enabled = true;</span></span><br><span class="line"><span class="comment">               btn_wangkouCLOSE.Enabled = false;</span></span><br><span class="line"><span class="comment">               MessageBox.Show(&quot;连接服务器失败！&quot;);</span></span><br><span class="line"><span class="comment">               rtb_textshow.Text = &quot;连接服务器失败。。。请仔细检查服务器是否开启&quot; + ee;</span></span><br><span class="line"><span class="comment">               return;</span></span><br><span class="line"><span class="comment">           &#125;</span></span><br><span class="line"><span class="comment">           ******/</span></span><br><span class="line">           <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="meta">#<span class="keyword">endregion</span></span></span><br></pre></td></tr></table></figure><h4 id="断开网络连接"><a href="#断开网络连接" class="headerlink" title="断开网络连接"></a>断开网络连接</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">region</span> 断开网络连接</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">btn_wangkouCLOSE_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//保证是在连接状态下退出</span></span><br><span class="line">            <span class="keyword">if</span> (SFlag == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">byte</span>[] send = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                send = Encoding.ASCII.GetBytes(<span class="string">&quot;*close*&quot;</span>);  <span class="comment">//关闭客户端时给服务器发送一个退出标志</span></span><br><span class="line">                ClientSocket.Send(send);</span><br><span class="line"></span><br><span class="line">                th1.Abort();    <span class="comment">//关闭线程</span></span><br><span class="line">                ClientSocket.Close();   <span class="comment">//关闭套接字</span></span><br><span class="line"></span><br><span class="line">                btn_wangkouOPEN.Enabled = <span class="literal">true</span>;  <span class="comment">//允许操作按钮</span></span><br><span class="line">                SFlag = <span class="number">0</span>;  <span class="comment">//客户端退出后将连接成功标志程序设置为0</span></span><br><span class="line">                rtb_textshow.Text += DateTime.Now.ToString(<span class="string">&quot;yy-MM-dd hh:mm:ss  &quot;</span>);</span><br><span class="line">                rtb_textshow.Text += <span class="string">&quot;客户端已关闭&quot;</span> + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                MessageBox.Show(<span class="string">&quot;已关闭连接&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#<span class="keyword">endregion</span></span></span><br></pre></td></tr></table></figure><h4 id="接收服务器端数据"><a href="#接收服务器端数据" class="headerlink" title="接收服务器端数据"></a>接收服务器端数据</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">region</span> 接收服务器端数据</span></span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">Receive</span>(<span class="params">Object sk</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           Socket socketRec = sk <span class="keyword">as</span> Socket;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="comment">//5.接收数据</span></span><br><span class="line">               <span class="comment">//byte[] receive = new byte[4];                 //receive是十进制字节数组</span></span><br><span class="line">               ClientSocket.Receive(receive);  <span class="comment">//调用Receive()接收字节数据</span></span><br><span class="line">               left_temp = receive[<span class="number">0</span>];</span><br><span class="line">               right_temp = receive[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">               <span class="comment">//6.打印接收数据</span></span><br><span class="line">               <span class="keyword">if</span> (receive.Length &gt; <span class="number">0</span>)</span><br><span class="line">               &#123;</span><br><span class="line">                   rtb_textshow.Text += DateTime.Now.ToString(<span class="string">&quot;yy-MM-dd hh:mm:ss  &quot;</span>) + <span class="string">&quot;接收：&quot;</span>;   <span class="comment">//打印接收时间</span></span><br><span class="line">                   <span class="comment">//rtb_textshow.Text += byteToHexStr(receive) + &quot;\r\n&quot;;  //将字节数据根据ASCII码转成字符串   //字符显示Encoding.ASCII.GetString(receive)        //16进制显示byteToHexStr(receive)</span></span><br><span class="line">                   <span class="comment">//rtb_textshow.Text += rtb_send.Text + &quot;\r\n&quot;;                                                                                  //rtb_textshow.Text += BitConverter.ToInt32(receive,0) + &quot;\r\n&quot;;</span></span><br><span class="line">                   rtb_textshow.Text += <span class="string">&quot;左边温度：&quot;</span> + left_temp + <span class="string">&quot;\r\n&quot;</span>;                       <span class="comment">//已经是十进制了</span></span><br><span class="line">                   rtb_textshow.Text += <span class="string">&quot;右边温度：&quot;</span> + right_temp + <span class="string">&quot;\r\n&quot;</span>;    </span><br><span class="line"></span><br><span class="line">                   <span class="comment">//测试receive[0]数据类型</span></span><br><span class="line">                   <span class="comment">//rtb_textshow.Text += Convert.ToString(left_temp_high).GetType();                //system.string</span></span><br><span class="line">                   <span class="comment">//rtb_textshow.Text += receive[0];//.GetType();                                //receive[0] = 12 (ASCII码值）     //system.byte</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="meta">#<span class="keyword">endregion</span></span></span><br></pre></td></tr></table></figure><h4 id="向服务器端发送数据"><a href="#向服务器端发送数据" class="headerlink" title="向服务器端发送数据"></a>向服务器端发送数据</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">region</span> 向服务器端发送数据</span></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">btn_send_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">if</span> (SFlag == <span class="number">1</span>)</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="built_in">byte</span>[] send = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                   send = HexStringToByteArray(rtb_send.Text);</span><br><span class="line">                   <span class="comment">//send = Encoding.ASCII.GetBytes(rtb_send.Text);  //将文本内容转换成字节发送</span></span><br><span class="line">                   ClientSocket.Send(send);    <span class="comment">//调用Send()函数发送数据</span></span><br><span class="line"></span><br><span class="line">                   rtb_textshow.Text += DateTime.Now.ToString(<span class="string">&quot;yy-MM-dd hh:mm:ss  &quot;</span>) + <span class="string">&quot;发送：&quot;</span>;   <span class="comment">//打印发送数据的时间</span></span><br><span class="line">                   rtb_textshow.Text += rtb_send.Text + <span class="string">&quot;\n&quot;</span>;   <span class="comment">//打印发送的数据  rtb_send.Text + &quot;\n&quot;; </span></span><br><span class="line">                   rtb_send.Clear();   <span class="comment">//清空发送框</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       <span class="meta">#<span class="keyword">endregion</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、Socket网络编程&quot;&gt;&lt;a href=&quot;#一、Socket网络编程&quot; class=&quot;headerlink&quot; title=&quot;一、Socket网络编程&quot;&gt;&lt;/a&gt;一、Socket网络编程&lt;/h2&gt;&lt;p&gt;Socket：套接字，用于描述IP地址和端口，是一个通信链的</summary>
      
    
    
    
    <category term="C#网络编程" scheme="https://shenlou99.github.io/categories/C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C#,网络开发" scheme="https://shenlou99.github.io/tags/C-%E7%BD%91%E7%BB%9C%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>算法（四）——寻找数组中前三最大值</title>
    <link href="https://shenlou99.github.io/2023/02/02/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E5%89%8D%E4%B8%89%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <id>https://shenlou99.github.io/2023/02/02/%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E5%89%8D%E4%B8%89%E6%9C%80%E5%A4%A7%E5%80%BC/</id>
    <published>2023-02-02T08:09:24.000Z</published>
    <updated>2023-03-11T07:36:34.472Z</updated>
    
    <content type="html"><![CDATA[<h2 id="寻找数组最大值"><a href="#寻找数组最大值" class="headerlink" title="寻找数组最大值"></a>寻找数组最大值</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//寻找数组前三最大值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">find_max</span><span class="params">(<span class="type">int</span> *arr,<span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> firstmax=<span class="number">0</span>,secondmax=<span class="number">0</span>,thirdmax=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> first_num=<span class="number">0</span>,second_num=<span class="number">0</span>,third_num=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">        firstmax = arr[lowest_count];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]==firstmax || arr[i]==secondmax || arr[i]==thirdmax) <span class="keyword">continue</span>; <span class="comment">//去重</span></span><br><span class="line">            <span class="keyword">if</span>(firstmax &lt;= arr[i])</span><br><span class="line">            &#123;</span><br><span class="line">                thirdmax = secondmax;</span><br><span class="line">                third_num = second_num;</span><br><span class="line">                secondmax = firstmax;</span><br><span class="line">                second_num = first_num;</span><br><span class="line">                firstmax = arr[i];</span><br><span class="line">                first_num = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(secondmax &lt;= arr[i])</span><br><span class="line">            &#123;</span><br><span class="line">                thirdmax = secondmax;</span><br><span class="line">                third_num = second_num;</span><br><span class="line">                secondmax = arr[i];</span><br><span class="line">                second_num = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(thirdmax &lt;= arr[i])</span><br><span class="line">            &#123;</span><br><span class="line">                    thirdmax = arr[i];</span><br><span class="line">                    third_num = i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//            printf(&quot;第一个最大值：%d，第一个最大值下标：%d\n&quot;,firstmax,first_num);</span></span><br><span class="line"><span class="comment">//            printf(&quot;第二个最大值：%d，第二个最大值下标：%d\n&quot;,secondmax,second_num);</span></span><br><span class="line"><span class="comment">//            printf(&quot;第三个最大值：%d，第三个最大值下标：%d\n&quot;,thirdmax,third_num);</span></span><br><span class="line"><span class="comment">//            printf(&quot;\n&quot;);</span></span><br><span class="line">            <span class="comment">//printf(&quot;第%d次：第一最大值：%d，第二最大值：%d，第三最大值：%d\n\n&quot;,i+1,firstmax,secondmax,thirdmax);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;第一个最大值firstmax：%d，第一个最大值下标first_num：%d\n&quot;</span>,firstmax,first_num);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;第二个最大值secondmax：%d，第二个最大值下标second_num：%d\n&quot;</span>,secondmax,second_num);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;第三个最大值thirdmax：%d，第三个最大值下标third_num：%d\n&quot;</span>,thirdmax,third_num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;寻找数组最大值&quot;&gt;&lt;a href=&quot;#寻找数组最大值&quot; class=&quot;headerlink&quot; title=&quot;寻找数组最大值&quot;&gt;&lt;/a&gt;寻找数组最大值&lt;/h2&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut</summary>
      
    
    
    
    <category term="算法" scheme="https://shenlou99.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="寻找数组最大值" scheme="https://shenlou99.github.io/tags/%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>算法（三）——数组寻找众数</title>
    <link href="https://shenlou99.github.io/2023/02/02/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84%E5%AF%BB%E6%89%BE%E4%BC%97%E6%95%B0/"/>
    <id>https://shenlou99.github.io/2023/02/02/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84%E5%AF%BB%E6%89%BE%E4%BC%97%E6%95%B0/</id>
    <published>2023-02-02T08:07:05.000Z</published>
    <updated>2023-03-11T07:36:34.471Z</updated>
    
    <content type="html"><![CDATA[<h2 id="寻找众数"><a href="#寻找众数" class="headerlink" title="寻找众数"></a>寻找众数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">函数功能：找出出现次数最多的数</span></span><br><span class="line"><span class="comment">传入参数：arr：原数组，len：原数组长度</span></span><br><span class="line"><span class="comment">返 回 值：del_temp：需要剔除的元素，del_len：剔除后的数据长度</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">max_count_num</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> * arr, <span class="type">unsigned</span> <span class="type">char</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> del_len;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i, j;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> m;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> count;</span><br><span class="line"><span class="comment">//定义次数存储数组</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> max[len];</span><br><span class="line"><span class="comment">//数组初始化</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">max[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对数组中的元素进行count</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (j = i; j &lt; len; j++)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i] == arr[j])</span><br><span class="line">&#123;</span><br><span class="line">max[i]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取出数组中元素的最大值</span></span><br><span class="line">m = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (max[m] &lt; max[i]) &#123;</span><br><span class="line">m = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n出现次数最多的元素为：%d， 出现次数为：%d\n&quot;</span>, arr[m],max[m]);</span><br><span class="line">del_temp = arr[m];              <span class="comment">//删除出现最多的元素</span></span><br><span class="line">del_len = len - max[m];         <span class="comment">//删除出现次数</span></span><br><span class="line"><span class="keyword">return</span> del_len;                 <span class="comment">//返回剔除出现最多次数元素的长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;寻找众数&quot;&gt;&lt;a href=&quot;#寻找众数&quot; class=&quot;headerlink&quot; title=&quot;寻找众数&quot;&gt;&lt;/a&gt;寻找众数&lt;/h2&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s</summary>
      
    
    
    
    <category term="算法" scheme="https://shenlou99.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="众数" scheme="https://shenlou99.github.io/tags/%E4%BC%97%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>算法（二）——将数组以众数形式呈现</title>
    <link href="https://shenlou99.github.io/2023/02/02/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E5%B0%86%E6%95%B0%E7%BB%84%E4%BB%A5%E4%BC%97%E6%95%B0%E5%BD%A2%E5%BC%8F%E5%91%88%E7%8E%B0/"/>
    <id>https://shenlou99.github.io/2023/02/02/%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E5%B0%86%E6%95%B0%E7%BB%84%E4%BB%A5%E4%BC%97%E6%95%B0%E5%BD%A2%E5%BC%8F%E5%91%88%E7%8E%B0/</id>
    <published>2023-02-02T08:01:30.000Z</published>
    <updated>2023-03-11T07:36:34.471Z</updated>
    
    <content type="html"><![CDATA[<h2 id="将数组以众数形式呈现"><a href="#将数组以众数形式呈现" class="headerlink" title="将数组以众数形式呈现"></a>将数组以众数形式呈现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/********</span></span><br><span class="line"><span class="comment">输入参数：1.原数组 2.原数组长度</span></span><br><span class="line"><span class="comment">输 出 值：众数形式呈现的数组</span></span><br><span class="line"><span class="comment">*******/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> origin_len 20</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *<span class="title function_">find_zs</span><span class="params">(<span class="type">int</span> *arr,<span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j=<span class="number">0</span>,k;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> newarr[origin_len];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        newarr[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;众数数组：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        j = arr[i];</span><br><span class="line">        <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;len;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j == arr[k])</span><br><span class="line">            &#123;</span><br><span class="line">                newarr[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//printf(&quot;%d &quot;,newarr[i]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i+<span class="number">1</span>]==arr[i])</span><br><span class="line">        &#123;</span><br><span class="line">            newarr[i+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,newarr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> newarr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;将数组以众数形式呈现&quot;&gt;&lt;a href=&quot;#将数组以众数形式呈现&quot; class=&quot;headerlink&quot; title=&quot;将数组以众数形式呈现&quot;&gt;&lt;/a&gt;将数组以众数形式呈现&lt;/h2&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t</summary>
      
    
    
    
    <category term="算法" scheme="https://shenlou99.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="寻找众数" scheme="https://shenlou99.github.io/tags/%E5%AF%BB%E6%89%BE%E4%BC%97%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>算法（一）——冒泡排序</title>
    <link href="https://shenlou99.github.io/2023/02/02/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>https://shenlou99.github.io/2023/02/02/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</id>
    <published>2023-02-02T07:58:15.000Z</published>
    <updated>2023-03-11T07:36:34.470Z</updated>
    
    <content type="html"><![CDATA[<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mp</span><span class="params">(<span class="type">int</span> *arr,<span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;len<span class="number">-1</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序树组：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h2&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s</summary>
      
    
    
    
    <category term="算法" scheme="https://shenlou99.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="排序" scheme="https://shenlou99.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>C语言实例（三）——九九乘法表</title>
    <link href="https://shenlou99.github.io/2023/01/29/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E4%BE%8B%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E4%B9%9D%E4%B9%9D%E4%B9%98%E6%B3%95%E8%A1%A8/"/>
    <id>https://shenlou99.github.io/2023/01/29/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E4%BE%8B%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E4%B9%9D%E4%B9%9D%E4%B9%98%E6%B3%95%E8%A1%A8/</id>
    <published>2023-01-29T01:51:23.000Z</published>
    <updated>2023-03-11T07:36:34.460Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*****</span></span><br><span class="line"><span class="comment">题目：输出9*9口诀。</span></span><br><span class="line"><span class="comment">******/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;<span class="number">10</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">9</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%dx%d=%d\n&quot;</span>,i,j,i*j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%dx%d=%d &quot;</span>,i,j,i*j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li</summary>
      
    
    
    
    <category term="C实例" scheme="https://shenlou99.github.io/categories/C%E5%AE%9E%E4%BE%8B/"/>
    
    
    <category term="C" scheme="https://shenlou99.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>stc单片机修改程序起始地址注意点</title>
    <link href="https://shenlou99.github.io/2023/01/29/stc%E5%8D%95%E7%89%87%E6%9C%BA%E4%BF%AE%E6%94%B9%E7%A8%8B%E5%BA%8F%E8%B5%B7%E5%A7%8B%E5%9C%B0%E5%9D%80%E6%B3%A8%E6%84%8F%E7%82%B9/"/>
    <id>https://shenlou99.github.io/2023/01/29/stc%E5%8D%95%E7%89%87%E6%9C%BA%E4%BF%AE%E6%94%B9%E7%A8%8B%E5%BA%8F%E8%B5%B7%E5%A7%8B%E5%9C%B0%E5%9D%80%E6%B3%A8%E6%84%8F%E7%82%B9/</id>
    <published>2023-01-29T00:17:14.000Z</published>
    <updated>2023-03-11T07:36:34.467Z</updated>
    
    <content type="html"><![CDATA[<p>1.A51文件中更改AT值，即导致startup复位中断向量地址更改。<br>2.target的中断偏移向量更改，即导致单片机的中断偏移向量表更改。<br>3.更改target的EEPROM首地址，则导致单片机的用户程序地址更改。</p><p>所以，AT值和中断偏移值，不能和EEPROM首地址重合，否则会覆盖用户程序，导致用户程序无法运行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1.A51文件中更改AT值，即导致startup复位中断向量地址更改。&lt;br&gt;2.target的中断偏移向量更改，即导致单片机的中断偏移向量表更改。&lt;br&gt;3.更改target的EEPROM首地址，则导致单片机的用户程序地址更改。&lt;/p&gt;
&lt;p&gt;所以，AT值和中断偏移值，不</summary>
      
    
    
    
    <category term="单片机" scheme="https://shenlou99.github.io/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="stc" scheme="https://shenlou99.github.io/tags/stc/"/>
    
  </entry>
  
  <entry>
    <title>软件版本号命名规则</title>
    <link href="https://shenlou99.github.io/2023/01/26/%E8%BD%AF%E4%BB%B6%E7%89%88%E6%9C%AC%E5%8F%B7%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/"/>
    <id>https://shenlou99.github.io/2023/01/26/%E8%BD%AF%E4%BB%B6%E7%89%88%E6%9C%AC%E5%8F%B7%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/</id>
    <published>2023-01-26T06:52:51.000Z</published>
    <updated>2023-03-11T07:36:34.473Z</updated>
    
    <content type="html"><![CDATA[<p><strong>格式：</strong></p><p><strong>主版本号.子版本号.修订版本号.日期_版本阶段</strong></p><p>比如：V1.2.3.20220513_rc</p><p><strong>说明：</strong></p><p><strong>第一位（1）</strong>：主版本号。当功能模块有较大的变动，比如增加多个模块或者整体架构发生变化。此版本号由项目决定是否修改。</p><p><strong>第二位（2）</strong>：子版本号。当功能有一定的增加或变化，比如增加了对权限控制、增加自定义视图等功能。此版本号由项目决定是否修改。</p><p><strong>第三位（3）</strong>：修订版本号。一般是 Bug 修复或是一些小的变动，要经常发布修订版，时间间隔不限，修复一个严重的bug即可发布一个修订版。此版本号由项目经理决定是否修改。</p><p><strong>日期版本号（20201228）</strong>：用于记录修改项目的当前日期，每天对项目的修改都需要更改日期版本号。此版本号由开发人员决定是否修改。</p><p>**希腊字母版本号(rc)**：此版本号用于标注当前版本的软件处于哪个开发阶段，当软件进入到另一个阶段时需要修改此版本号。此版本号由项目决定是否修改。</p><p><strong>软件版本阶段说明：</strong></p><p><strong>Base版:</strong> 此版本表示该软件仅仅是一个假页面链接，通常包括所有的功能和页面布局，但是页面中的功能都没有做完整的实现，只是作为整体网站的一个基础架构。</p><p><strong>Alpha版:</strong> 此版本表示该软件在此阶段主要是以实现软件功能为主，通常只在软件开发者内部交流，一般而言，该版本软件的Bug较多，需要继续修改。</p><p><strong>Beta版:</strong> 该版本相对于α版已有了很大的改进，消除了严重的错误，但还是存在着一些缺陷，需要经过多次测试来进一步消除，此版本主要的修改对象是软件的UI。</p><p><strong>RC版:</strong> 该版本已经相当成熟了，基本上不存在导致错误的BUG，与即将发行的正式版相差无几。</p><p><strong>Release版:</strong> 该版本意味“最终版本”，在前面版本的一系列测试版之后，终归会有一个正式版本，是最终交付用户使用的一个版本。该版本有时也称为标准版。一般情况下，Release不会以单词形式出现在软件封面上，取而代之的是符号(Ｒ)。</p><p>当然还有一些大家经常在某些软件上看到版本所包含的英文词语，如果看不懂就比较尴尬了，但有一个测试版和一个专业版摆在面前，却因为不太了解这些常规命名而选错，下面大致了解下：</p><ul><li><p><strong>standard：标准版</strong></p></li><li><p><strong>full version：完整版，即正式版</strong></p></li><li><p><strong>lts：长期维护版本</strong></p></li><li><p><strong>ultimate：旗舰版</strong></p></li><li><p><strong>alpha：内部版本</strong></p></li><li><p><strong>beta：测试版</strong></p></li><li><p><strong>demo：演示版</strong></p></li><li><p><strong>enhance：增强版</strong></p></li><li><p><strong>free：自由版</strong></p></li><li><p><strong>lts：长期维护版本</strong></p></li><li><p><strong>release：发行版</strong></p></li><li><p><strong>rc：即将作为正式版发布</strong></p></li><li><p><strong>standard：标准版</strong></p></li><li><p><strong>upgrade：升级版</strong></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;格式：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主版本号.子版本号.修订版本号.日期_版本阶段&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如：V1.2.3.20220513_rc&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;str</summary>
      
    
    
    
    
    <category term="软件版本命名规则" scheme="https://shenlou99.github.io/tags/%E8%BD%AF%E4%BB%B6%E7%89%88%E6%9C%AC%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/"/>
    
  </entry>
  
</feed>
